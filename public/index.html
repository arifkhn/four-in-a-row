<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>4-in-a-Row ‚Äî Multiplayer</title>
  <audio id="remote-audio" autoplay playsinline></audio>
  <style>
    :root {
      --cell: min(calc(98vw / 8), calc(98vh / 8), 36px);
      --accent: #0ea5e9;
      --bg: linear-gradient(180deg,#f6f8ff,#eef2ff);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      font-family:Inter,system-ui,Segoe UI,Arial;
      background:var(--bg);
      color:#0f172a;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:10px;
      gap:10px;
    }
    header{width:100%;max-width:1100px;display:flex;justify-content:space-between;align-items:center}
    h1{font-size:18px;margin:0}
    .sub{font-size:13px;color:#475569}

    #wrap{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap;justify-content:center;width:100%;max-width:1100px}
    #board{
      display:grid;
      grid-template-columns:repeat(8,var(--cell));
      grid-template-rows:repeat(8,var(--cell));
      gap:4px;
      background:#2b2f3a;padding:6px;border-radius:10px;
      box-shadow:0 6px 18px rgba(2,6,23,0.08);
      touch-action:manipulation;
    }
    .cell{
      width:var(--cell);height:var(--cell);
      background:#fff;border-radius:6px;display:flex;align-items:center;justify-content:center;
      cursor:pointer;transition:transform .08s ease,box-shadow .12s;
      user-select:none;
    }
    .cell:active{transform:translateY(1px)}
    .black,.white{width:76%;height:76%;border-radius:50%;box-shadow:0 1px 0 rgba(0,0,0,0.06) inset}
    .black{background:#0b0b0b;border:2px solid #333333}
    .white{background:#016ca6;border:2px solid #83b9ff}

    #panel{min-width:220px;display:flex;flex-direction:column;gap:8px;align-items:flex-start}
    #status{font-weight:700}
    #players{font-size:13px;color:#334155}
    #controls{display:flex;gap:8px;flex-wrap:wrap}
    button{padding:8px 10px;border:0;border-radius:8px;background:var(--accent);color:#042a2b;font-weight:600;cursor:pointer}
    button.secondary{background:#e6f7ff;color:#034054}
    footer{color:#475569;font-size:13px;text-align:center;width:100%}

    .glow{box-shadow:0 0 0 3px rgba(250,204,21,0.22),0 8px 18px rgba(2,6,23,0.12)}

    @media (max-width:720px){
      :root{--cell: calc(78vw / 8)}
      #panel{width:100%;align-items:center}
      #wrap{flex-direction:column;align-items:center}
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>4-in-a-Row ‚Äî Multiplayer (Gravity)</h1>
      <div class="sub">Place pieces into columns. Bottom-most empty slot rule applies. First to get 4 in a row wins.</div>
    </div>
    <div id="me" class="sub">Connecting...</div>
  </header>

  <div id="wrap">
    <div id="board" aria-label="game board" role="grid"></div>

    <div id="panel">
      <div id="status">Waiting for assignment...</div>
      <div id="players">Black: ‚Äî | White: ‚Äî</div>
      <div id="controls">
        <button id="reset">Restart</button>
        <button id="hint" class="secondary">Show last</button>
      </div>
      <div style="font-size:13px;color:#334155">
        Tip: Open the page on two devices/browsers to play. Additional visitors will be spectators.
      </div>
      <div id="chat-box" style="width: 100%; max-height: 200px; overflow-y: scroll; border: 1px solid #ddd; padding: 5px; border-radius: 6px; background: #fff; margin-top: 10px;">
          </div>
      <div id="chat-input-wrap" style="width: 100%; display: flex; gap: 5px;">
          <input type="text" id="chat-input" placeholder="Type a message..." style="flex-grow: 1; padding: 8px; border-radius: 6px; border: 1px solid #ccc;">
          <button id="send-chat" style="padding: 8px 10px; background: var(--accent); color: white;">Send</button>
      </div>
      <div id="voice-controls" style="width: 100%; display: flex; gap: 8px; margin-top: 10px;">
          <button id="toggle-mic" class="secondary" style="background: #e6f7ff; color: #034054;">üéôÔ∏è Mic OFF</button>
          <button id="toggle-speaker" class="secondary" style="background: #e6f7ff; color: #034054;">üîä Speaker ON</button>
      </div>
    </div>
  </div>

  <footer>Built with Socket.IO ‚Ä¢ Server must be run locally (node server.js)</footer>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const SIZE = 8;
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const playersEl = document.getElementById('players');
    const meEl = document.getElementById('me');
    const resetBtn = document.getElementById('reset');
    const hintBtn = document.getElementById('hint');
    const chatBoxEl = document.getElementById('chat-box');
    const chatInputEl = document.getElementById('chat-input');
    const sendChatBtn = document.getElementById('send-chat');
    const toggleMicBtn = document.getElementById('toggle-mic');
    const toggleSpeakerBtn = document.getElementById('toggle-speaker');

    let localStream = null;
    let micOn = false;
    let speakerOn = true;

    const socket = io();


    // WebRTC-specific variables
    let peerConnection = null; 
    const remoteAudio = document.createElement('audio'); // Also ensure this is global
    remoteAudio.autoplay = true;
    remoteAudio.playsinline = true; 

    // üéØ THE MISSING DEFINITION FIX:
    const iceServers = {
        iceServers: [
            // Essential public STUN servers for NAT traversal
            { urls: 'stun:stun.l.google.com:19302' }, 
            { urls: 'stun:stun1.l.google.com:19302' },
        ]
    };



    // robust roomId extraction
    const pathParts = window.location.pathname.split("/").filter(Boolean); // remove empty parts
    const roomId = pathParts[pathParts.length - 1]; // last element (works for /room/<id> and /room/<id>/)


    socket.emit("joinRoom", roomId);

¬† ¬† function findGravityRow(c) {
        // Iterate from the bottom row (SIZE - 1) up to the top row (0)
        for (let r = SIZE - 1; r >= 0; r--) {
            if (grid[r][c] === null) {
                return r; // Found the lowest empty cell
            }
        }
        return -1; // Column is full
    }

¬† ¬† function handleCellClick(c) { // We only need the column index 'c'
¬† ¬† ¬† if (!myRole) return;
¬† ¬† ¬† if (myRole === 'spectator') {
¬† ¬† ¬† ¬† alert('You are a spectator.');
¬† ¬† ¬† ¬† return;
¬† ¬† ¬† }
¬† ¬† ¬† if (gameOver) return;

        // --- Gravity Rule Implementation ---
        const r = findGravityRow(c);
        if (r === -1) {
            flashStatus('Column is full!');
            return;
        }
      socket.emit('makeMove', { r, c });
¬† ¬† }




    // Function to handle sending the message
    function sendChatMessage() {
        const message = chatInputEl.value.trim();
        if (message) {
            // Find the room ID (it's already defined globally as 'roomId')
            socket.emit('sendMessage', { roomId, message });
            chatInputEl.value = ''; // Clear the input
        }
    }

    // Event listeners for chat
    sendChatBtn.addEventListener('click', sendChatMessage);
    chatInputEl.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            sendChatMessage();
        }
    });




    let myRole = null; // 'black'|'white'|'spectator'
    let grid = Array.from({length: SIZE}, () => Array(SIZE).fill(null));
    let currentPlayer = 'black';
    let gameOver = false;
    let lastMove = null;

    // Create board cells
    function createBoard() {
      boardEl.innerHTML = '';
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.r = r;
          cell.dataset.c = c;
          
          boardEl.appendChild(cell);
        }
      }
      renderGrid();

      boardEl.addEventListener('click', (event) => {
          const cell = event.target.closest('.cell');
          if (cell) {
              const c = parseInt(cell.dataset.c, 10);
              handleCellClick(c);
          }
      });
    }

    function renderGrid() {
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const el = boardEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
          el.innerHTML = '';
          el.style.boxShadow = '';
          const val = grid[r][c];
          if (val === 'black' || val === 'white') {
            const dot = document.createElement('div');
            dot.className = val;
            el.appendChild(dot);
          }
        }
      }
    }




    // Function to control the local microphone
    toggleMicBtn.addEventListener('click', () => {
        if (micOn) {
            // Turn OFF microphone
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            micOn = false;
            toggleMicBtn.textContent = 'üéôÔ∏è Mic OFF';
            toggleMicBtn.style.backgroundColor = '#e6f7ff';
        } else {
            // Turn ON microphone and request access
            navigator.mediaDevices.getUserMedia({ audio: true, video: false })
                .then(stream => {
                    localStream = stream;
                    peerConnection = new RTCPeerConnection(iceServers);
                    localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

                    // Check 1: Ensure the stream has an audio track
                    const audioTrack = localStream.getAudioTracks()[0];
                    if (audioTrack) {
                        // Check 2: Ensure the track is enabled before adding it to the connection
                        audioTrack.enabled = true; 
                        
                        // Add the track to the peer connection
                        // NOTE: Use addTrack for modern WebRTC, ensuring the track is added correctly
                        peerConnection.addTrack(audioTrack, localStream);
                    } else {
                        console.error("Mobile device failed to get an audio track.");
                        // You might want to show a user alert here
                    }


                    



                    peerConnection.ontrack = (event) => {
                        // Attach the received stream to the audio element
                        if (remoteAudio.srcObject !== event.streams[0]) {
                            remoteAudio.srcObject = event.streams[0];
                            // It's not visible, but it will output audio
                            document.body.appendChild(remoteAudio); 
                        }
                    };

                    // 4. Implement ICE Candidate Exchange
                    peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            // Send our network info (ICE candidate) to the other peer via the server
                            socket.emit('iceCandidate', { roomId, candidate: event.candidate });
                        }
                    };



                    // 5. Start the connection process (only the 'black' player initiates the call)
                    if (myRole === 'black') { 
                        // Create the initial connection offer
                        peerConnection.createOffer()
                            .then(offer => peerConnection.setLocalDescription(offer))
                            .then(() => {
                                // Send the offer to the other peer via the server
                                socket.emit('signaling', { roomId, signal: peerConnection.localDescription });
                            })
                            .catch(error => console.error("Error creating or sending offer:", error));
                    }



      
                    
                    // Conceptual: send this stream to peers via WebRTC logic (omitted here)
                    
                    micOn = true;
                    toggleMicBtn.textContent = 'üéôÔ∏è Mic ON';
                    toggleMicBtn.style.backgroundColor = 'lightgreen';
                })
                .catch(err => {
                    alert('Microphone access denied or failed: ' + err.name);
                    console.error("Microphone Error:", err);
                });
        }
    });


    // Function to conceptually control the speaker (mute/unmute incoming audio)
    toggleSpeakerBtn.addEventListener('click', () => {
        speakerOn = !speakerOn;
        
        if (speakerOn) {
            toggleSpeakerBtn.textContent = 'üîä Speaker ON';
            toggleSpeakerBtn.style.backgroundColor = '#e6f7ff';
            
            // Conceptual: Unmute all remote audio elements here
            // Example: document.querySelectorAll('audio').forEach(a => a.volume = 1);
            
        } else {
            toggleSpeakerBtn.textContent = 'üîá Speaker OFF';
            toggleSpeakerBtn.style.backgroundColor = 'red';

            // Conceptual: Mute all remote audio elements here
            // Example: document.querySelectorAll('audio').forEach(a => a.volume = 0);
        }
    });



    // Socket handlers
    socket.on('connect', () => {
      meEl.textContent = 'Connected';
    });

    socket.on('playerAssigned', (role) => {
      myRole = role;
      statusEl.textContent = role === 'spectator' ? 'You are a spectator' : `You are Player ${role}`;
    });

    socket.on('playerList', ({ black, white }) => {
      const b = black ? 'Connected' : '‚Äî';
      const w = white ? 'Connected' : '‚Äî';
      playersEl.textContent = `Black: ${b} | White: ${w}`;
    });


    socket.on('chatMessage', ({ senderRole, message }) => {
        const msgEl = document.createElement('div');
        const roleStyle = senderRole === 'black' ? 'font-weight: bold; color: #0b0b0b;' :
                          senderRole === 'white' ? 'font-weight: bold; color: #016ca6;' :
                          'color: #475569;';

        msgEl.innerHTML = `<span style="${roleStyle}">[${senderRole}]</span>: ${message}`;
        chatBoxEl.appendChild(msgEl);
        
        // Scroll to the bottom
        chatBoxEl.scrollTop = chatBoxEl.scrollHeight;
    });




    socket.on('signaling', async ({ senderId, signal }) => {
        if (!peerConnection) return; // Ignore if PC not set up

        try {
            if (signal.type === 'offer' && myRole === 'white') {
                // Player 'white' receives the offer, sets it, and creates an answer
                await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                // Send the answer back to the 'black' player
                socket.emit('signaling', { roomId, signal: peerConnection.localDescription });
                
            } else if (signal.type === 'answer' && myRole === 'black') {
                // Player 'black' receives the answer and completes the handshake
                await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));
            }
        } catch (error) {
            console.error("Error handling signaling message:", error);
        }
    });

    socket.on('iceCandidate', (payload) => {
        if (payload.candidate && peerConnection) {
            // Add the remote peer's network information
            peerConnection.addIceCandidate(new RTCIceCandidate(payload.candidate))
                .catch(error => console.error('Error adding received ICE candidate:', error));
        }
    });






    socket.on('gameState', (state) => {
      grid = state.grid;
      currentPlayer = state.currentPlayer;
      gameOver = state.gameOver;
      updateStatus();
      createBoard();
    });

    socket.on('updateBoard', ({ r, c, player }) => {
      grid[r][c] = player;
      lastMove = { r, c };
      renderGrid();
    });

    socket.on('turn', ({ currentPlayer: player }) => { // Server sends an object { currentPlayer: '...' }
        currentPlayer = player;
        updateStatus();
    });

    socket.on('gameOver', ({ winner }) => {
      gameOver = true;
      statusEl.textContent = `Player ${winner} wins! üéâ`;
      highlightWinCells(winner);
    });

    socket.on('invalid', (msg) => {
      // brief feedback
      console.warn('Invalid action:', msg);
      flashStatus(msg);
    });

    // UI helpers
    function updateStatus() {
      if (gameOver) return;

      if (!playersEl.textContent.includes('Connected')) {
          // This is a catch-all if we haven't received playerList yet
          statusEl.textContent = "Waiting for an opponent...";
          return;
      }

      if (myRole === 'spectator') {
        statusEl.textContent = `Spectating ‚Äî ${currentPlayer}'s turn`;
      } else {
        // Determine if it's the current player's turn
          if (myRole === currentPlayer) {
              statusEl.textContent = `Your turn (${currentPlayer})`;
          } else {
              statusEl.textContent = `Opponent's turn (${currentPlayer})`;
          }
      }
    }

    function flashStatus(text) {
      const prev = statusEl.textContent;
      statusEl.textContent = text;
      setTimeout(() => updateStatus(), 900);
    }

    function highlightWinCells(winner) {
      // Visual: highlight all winner cells that are part of a 3 chain
      // collect all winning triples by scanning grid
      const dirs = [[1,0],[0,1],[1,1],[1,-1]];
      for (let r=0;r<SIZE;r++){
        for (let c=0;c<SIZE;c++){
          if (grid[r][c] !== winner) continue;
          for (const [dr,dc] of dirs){
            const cells = [[r,c]];
            let rr=r+dr, cc=c+dc;
            while (rr>=0 && rr<SIZE && cc>=0 && cc<SIZE && grid[rr][cc]===winner){
              cells.push([rr,cc]); rr+=dr; cc+=dc;
            }
            // check backwards too
            rr=r-dr; cc=c-dc;
            while (rr>=0 && rr<SIZE && cc>=0 && cc<SIZE && grid[rr][cc]===winner){
              cells.unshift([rr,cc]); rr-=dr; cc-=dc;
            }
            if (cells.length >= 4) {
              // highlight first contiguous 4 in this run
              for (let i=0;i<cells.length;i++){
                if (i+2 < cells.length){
                  const trio = [cells[i], cells[i+1], cells[i+2]];
                  trio.forEach(([ar,ac])=>{
                    const el = boardEl.querySelector(`.cell[data-r="${ar}"][data-c="${ac}"]`);
                    if (el) el.classList.add('glow');
                  });
                }
              }
            }
          }
        }
      }
    }

    resetBtn.addEventListener("click", () => {
      // ensure we pass roomId so server can restart the correct room
      socket.emit("restart", roomId);
    });




    hintBtn.addEventListener('click', () => {
      if (!lastMove) return;
      const el = boardEl.querySelector(`.cell[data-r="${lastMove.r}"][data-c="${lastMove.c}"]`);
      if (!el) return;
      const orig = el.style.transform;
      el.style.transform = 'scale(1.08)';
      setTimeout(()=> el.style.transform = orig, 300);
    });

    // init
    createBoard();
  </script>
</body>
</html>
